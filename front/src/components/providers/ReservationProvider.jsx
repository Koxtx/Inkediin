import React, {  useContext, useState, useEffect, useCallback } from 'react';
import { reservationsApi, reservationUtils } from '../../api/reservations.api';
import { AuthContext } from './AuthContext';
import { SocketContext } from './SocketContext';
import toast from 'react-hot-toast';



// Provider du contexte
export default function ReservationProvider({ children }) {
  const { user, currentUserId } = useContext(AuthContext);
  const { socket } = useContext(SocketContext);

  // √âtats principaux
  const [reservations, setReservations] = useState([]);
  const [userReservations, setUserReservations] = useState([]); // Pour les clients
  const [artistReservations, setArtistReservations] = useState([]); // Pour les tatoueurs
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // √âtats pour la pagination et les filtres
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [filters, setFilters] = useState({
    status: '',
    type: '',
    search: '',
    dateFrom: '',
    dateTo: ''
  });

  // Cache des r√©servations
  const [reservationCache, setReservationCache] = useState(new Map());

  // √âtats de statistiques
  const [stats, setStats] = useState({
    total: 0,
    pending: 0,
    confirmed: 0,
    completed: 0,
    cancelled: 0,
    rejected: 0,
    confirmationRate: 0
  });

  // Fonction pour mettre √† jour une r√©servation dans le cache
  const updateReservationInCache = useCallback((reservationId, updatedReservation) => {
    setReservationCache(prev => {
      const newCache = new Map(prev);
      newCache.set(reservationId, updatedReservation);
      return newCache;
    });
  }, []);

  // Mettre √† jour les statistiques
  const updateStats = useCallback(() => {
    const currentReservations = user?.userType === 'tatoueur' ? artistReservations : userReservations;
    const newStats = reservationUtils.calculateStats(currentReservations);
    setStats(newStats);
  }, [user, artistReservations, userReservations]);

  // Fonction pour mettre √† jour une r√©servation dans toutes les listes
  const updateReservationInAllLists = useCallback((reservationId, updatedReservation) => {
    const updateInList = (setList) => {
      setList(prev => prev.map(reservation =>
        reservation._id === reservationId ? updatedReservation : reservation
      ));
    };

    updateInList(setReservations);
    updateInList(setUserReservations);
    updateInList(setArtistReservations);

    // Mettre √† jour le cache
    updateReservationInCache(reservationId, updatedReservation);

    // Recalculer les stats
    updateStats();
  }, [updateReservationInCache, updateStats]);

  // Fonction pour supprimer une r√©servation de toutes les listes
  const removeReservationFromAllLists = useCallback((reservationId) => {
    const removeFromList = (setList) => {
      setList(prev => prev.filter(reservation => reservation._id !== reservationId));
    };

    removeFromList(setReservations);
    removeFromList(setUserReservations);
    removeFromList(setArtistReservations);

    // Supprimer du cache
    setReservationCache(prev => {
      const newCache = new Map(prev);
      newCache.delete(reservationId);
      return newCache;
    });

    // Recalculer les stats
    updateStats();
  }, [updateStats]);

  // Charger les r√©servations
  const loadReservations = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      console.log('üîÑ Chargement des r√©servations pour:', user?.userType);

      if (user?.userType === 'tatoueur') {
        // Charger les r√©servations pour le tatoueur
        const artistData = await reservationsApi.getArtistReservations({
          page: 1,
          limit: 50
        });
        console.log('üìã R√©servations artiste charg√©es:', artistData);
        
        const reservationsData = artistData.reservations || artistData.data || [];
        setArtistReservations(reservationsData);
        setReservations(reservationsData);

        // Mettre √† jour le cache
        reservationsData.forEach(reservation => {
          updateReservationInCache(reservation._id, reservation);
        });
      } else {
        // Charger les r√©servations pour le client
        const userData = await reservationsApi.getUserReservations({
          page: 1,
          limit: 50
        });
        console.log('üìã R√©servations utilisateur charg√©es:', userData);
        
        const reservationsData = userData.reservations || userData.data || [];
        setUserReservations(reservationsData);
        setReservations(reservationsData);

        // Mettre √† jour le cache
        reservationsData.forEach(reservation => {
          updateReservationInCache(reservation._id, reservation);
        });
      }

      // Mettre √† jour les stats
      updateStats();

    } catch (err) {
      console.error('‚ùå ReservationContext - Erreur chargement r√©servations:', err);
      setError(err.message || 'Erreur lors du chargement des r√©servations');
    } finally {
      setLoading(false);
    }
  }, [user, updateReservationInCache, updateStats]);

  // Cr√©er une r√©servation de flash
  const createFlashReservation = useCallback(async (reservationData) => {
    try {
      console.log('üìù Cr√©ation r√©servation flash:', reservationData);

      // Valider les donn√©es
      const validationErrors = reservationUtils.validateFlashReservation(reservationData);
      if (validationErrors.length > 0) {
        throw new Error(validationErrors[0]);
      }

      const newReservation = await reservationsApi.createFlashReservation(reservationData);
      console.log('‚úÖ R√©servation flash cr√©√©e:', newReservation);

      // Ajouter √† la liste des r√©servations utilisateur
      setUserReservations(prev => [newReservation, ...prev]);
      setReservations(prev => [newReservation, ...prev]);

      // Mettre √† jour le cache
      updateReservationInCache(newReservation._id, newReservation);

      // Recalculer les stats
      updateStats();

      toast.success('R√©servation envoy√©e avec succ√®s !');
      return newReservation;

    } catch (err) {
      console.error('‚ùå Erreur cr√©ation r√©servation flash:', err);
      toast.error(err.message || 'Erreur lors de la cr√©ation de la r√©servation');
      throw err;
    }
  }, [updateReservationInCache, updateStats]);

  // Cr√©er une r√©servation custom
  const createCustomReservation = useCallback(async (reservationData) => {
    try {
      console.log('üìù Cr√©ation r√©servation custom:', reservationData);

      // Valider les donn√©es
      const validationErrors = reservationUtils.validateCustomReservation(reservationData);
      if (validationErrors.length > 0) {
        throw new Error(validationErrors[0]);
      }

      const newReservation = await reservationsApi.createCustomReservation(reservationData);
      console.log('‚úÖ R√©servation custom cr√©√©e:', newReservation);

      // Ajouter √† la liste des r√©servations utilisateur
      setUserReservations(prev => [newReservation, ...prev]);
      setReservations(prev => [newReservation, ...prev]);

      // Mettre √† jour le cache
      updateReservationInCache(newReservation._id, newReservation);

      // Recalculer les stats
      updateStats();

      toast.success('Demande de tatouage personnalis√© envoy√©e !');
      return newReservation;

    } catch (err) {
      console.error('‚ùå Erreur cr√©ation r√©servation custom:', err);
      toast.error(err.message || 'Erreur lors de la cr√©ation de la r√©servation');
      throw err;
    }
  }, [updateReservationInCache, updateStats]);

  // R√©cup√©rer une r√©servation par ID
  const getReservationById = useCallback(async (reservationId) => {
    try {
      // V√©rifier d'abord le cache
      const cachedReservation = reservationCache.get(reservationId);
      if (cachedReservation) {
        console.log('üìã R√©servation trouv√©e dans le cache:', reservationId);
        return cachedReservation;
      }

      // Sinon, charger depuis l'API
      const reservation = await reservationsApi.getReservationById(reservationId);
      console.log('üìã R√©servation charg√©e depuis l\'API:', reservation);

      // Mettre √† jour le cache
      updateReservationInCache(reservationId, reservation);

      return reservation;
    } catch (err) {
      console.error('‚ùå Erreur r√©cup√©ration r√©servation:', err);
      throw err;
    }
  }, [reservationCache, updateReservationInCache]);

  // Mettre √† jour le statut d'une r√©servation (pour les tatoueurs)
  const updateReservationStatus = useCallback(async (reservationId, status, message = '') => {
    try {
      console.log('üîÑ Mise √† jour statut r√©servation:', { reservationId, status, message });

      const updatedReservation = await reservationsApi.updateReservationStatus(reservationId, status, message);
      
      // Mettre √† jour dans toutes les listes
      updateReservationInAllLists(reservationId, updatedReservation);

      const statusLabel = reservationUtils.getStatusLabel(status);
      toast.success(`R√©servation ${statusLabel.toLowerCase()}`);

      return updatedReservation;
    } catch (err) {
      console.error('‚ùå Erreur mise √† jour statut:', err);
      toast.error(err.message || 'Erreur lors de la mise √† jour');
      throw err;
    }
  }, [updateReservationInAllLists]);

  // Confirmer une r√©servation avec d√©tails de rendez-vous
  const confirmReservation = useCallback(async (reservationId, appointmentData) => {
    try {
      console.log('‚úÖ Confirmation r√©servation:', { reservationId, appointmentData });

      const updatedReservation = await reservationsApi.confirmReservation(reservationId, appointmentData);
      
      // Mettre √† jour dans toutes les listes
      updateReservationInAllLists(reservationId, updatedReservation);

      toast.success('R√©servation confirm√©e avec succ√®s !');
      return updatedReservation;
    } catch (err) {
      console.error('‚ùå Erreur confirmation r√©servation:', err);
      toast.error(err.message || 'Erreur lors de la confirmation');
      throw err;
    }
  }, [updateReservationInAllLists]);

  // Annuler une r√©servation
  const cancelReservation = useCallback(async (reservationId, reason = '') => {
    try {
      console.log('‚ùå Annulation r√©servation:', { reservationId, reason });

      const updatedReservation = await reservationsApi.cancelReservation(reservationId, reason);
      
      // Mettre √† jour dans toutes les listes
      updateReservationInAllLists(reservationId, updatedReservation);

      toast.success('R√©servation annul√©e');
      return updatedReservation;
    } catch (err) {
      console.error('‚ùå Erreur annulation r√©servation:', err);
      toast.error(err.message || 'Erreur lors de l\'annulation');
      throw err;
    }
  }, [updateReservationInAllLists]);

  // Modifier une r√©servation
  const updateReservation = useCallback(async (reservationId, updateData) => {
    try {
      console.log('üìù Modification r√©servation:', { reservationId, updateData });

      const updatedReservation = await reservationsApi.updateReservation(reservationId, updateData);
      
      // Mettre √† jour dans toutes les listes
      updateReservationInAllLists(reservationId, updatedReservation);

      toast.success('R√©servation modifi√©e avec succ√®s');
      return updatedReservation;
    } catch (err) {
      console.error('‚ùå Erreur modification r√©servation:', err);
      toast.error(err.message || 'Erreur lors de la modification');
      throw err;
    }
  }, [updateReservationInAllLists]);

  // Supprimer une r√©servation
  const deleteReservation = useCallback(async (reservationId) => {
    try {
      console.log('üóëÔ∏è Suppression r√©servation:', reservationId);

      await reservationsApi.deleteReservation(reservationId);
      
      // Supprimer de toutes les listes
      removeReservationFromAllLists(reservationId);

      toast.success('R√©servation supprim√©e');
    } catch (err) {
      console.error('‚ùå Erreur suppression r√©servation:', err);
      toast.error(err.message || 'Erreur lors de la suppression');
      throw err;
    }
  }, [removeReservationFromAllLists]);

  // Marquer une r√©servation comme termin√©e
  const completeReservation = useCallback(async (reservationId, completionData) => {
    try {
      console.log('üèÅ Finalisation r√©servation:', { reservationId, completionData });

      const updatedReservation = await reservationsApi.completeReservation(reservationId, completionData);
      
      // Mettre √† jour dans toutes les listes
      updateReservationInAllLists(reservationId, updatedReservation);

      toast.success('R√©servation marqu√©e comme termin√©e !');
      return updatedReservation;
    } catch (err) {
      console.error('‚ùå Erreur finalisation r√©servation:', err);
      toast.error(err.message || 'Erreur lors de la finalisation');
      throw err;
    }
  }, [updateReservationInAllLists]);

  // Envoyer un rappel
  const sendReminder = useCallback(async (reservationId, message) => {
    try {
      console.log('‚è∞ Envoi rappel:', { reservationId, message });

      await reservationsApi.sendReminder(reservationId, message);
      
      toast.success('Rappel envoy√© !');
    } catch (err) {
      console.error('‚ùå Erreur envoi rappel:', err);
      toast.error(err.message || 'Erreur lors de l\'envoi du rappel');
      throw err;
    }
  }, []);

  // Filtrer les r√©servations
  const getFilteredReservations = useCallback(() => {
    const currentReservations = user?.userType === 'tatoueur' ? artistReservations : userReservations;
    return reservationUtils.filterReservations(currentReservations, filters);
  }, [user, artistReservations, userReservations, filters]);

  // Grouper les r√©servations par statut
  const getGroupedReservations = useCallback(() => {
    const filteredReservations = getFilteredReservations();
    return reservationUtils.groupByStatus(filteredReservations);
  }, [getFilteredReservations]);

  // Obtenir les r√©servations √† venir
  const getUpcomingReservations = useCallback(() => {
    const currentReservations = user?.userType === 'tatoueur' ? artistReservations : userReservations;
    const now = new Date();
    
    return currentReservations
      .filter(reservation => {
        if (!reservation.appointmentDate) return false;
        const appointmentDate = new Date(reservation.appointmentDate);
        return appointmentDate > now && ['confirmed', 'in_progress'].includes(reservation.status);
      })
      .sort((a, b) => new Date(a.appointmentDate) - new Date(b.appointmentDate));
  }, [user, artistReservations, userReservations]);

  // Obtenir les r√©servations en attente (pour les tatoueurs)
  const getPendingReservations = useCallback(() => {
    if (user?.userType !== 'tatoueur') return [];
    
    return artistReservations.filter(reservation => reservation.status === 'pending');
  }, [user, artistReservations]);

  // Rafra√Æchir les donn√©es
  const refreshReservations = useCallback(async () => {
    try {
      setError(null);
      await loadReservations();
    } catch (err) {
      console.error('‚ùå Erreur refresh r√©servations:', err);
      setError(err.message);
    }
  }, [loadReservations]);

  // Vider l'erreur
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Mettre √† jour les filtres
  const updateFilters = useCallback((newFilters) => {
    setFilters(prev => ({ ...prev, ...newFilters }));
  }, []);

  // R√©initialiser les filtres
  const resetFilters = useCallback(() => {
    setFilters({
      status: '',
      type: '',
      search: '',
      dateFrom: '',
      dateTo: ''
    });
  }, []);

  // Charger plus de r√©servations (pagination)
  const loadMoreReservations = useCallback(async () => {
    if (!hasMore || loading) return;

    try {
      setLoading(true);
      const nextPage = currentPage + 1;

      const apiCall = user?.userType === 'tatoueur' 
        ? reservationsApi.getArtistReservations 
        : reservationsApi.getUserReservations;

      const response = await apiCall({
        page: nextPage,
        limit: 20,
        ...filters
      });

      const newReservations = response.reservations || response.data || [];

      if (newReservations.length > 0) {
        if (user?.userType === 'tatoueur') {
          setArtistReservations(prev => [...prev, ...newReservations]);
        } else {
          setUserReservations(prev => [...prev, ...newReservations]);
        }
        
        setCurrentPage(nextPage);
        setHasMore(nextPage < (response.totalPages || 1));

        // Mettre √† jour le cache
        newReservations.forEach(reservation => {
          updateReservationInCache(reservation._id, reservation);
        });
      } else {
        setHasMore(false);
      }
    } catch (err) {
      console.error('‚ùå Erreur load more r√©servations:', err);
    } finally {
      setLoading(false);
    }
  }, [hasMore, loading, currentPage, filters, user, updateReservationInCache]);

  // Gestion des √©v√©nements WebSocket
  useEffect(() => {
    if (socket && user) {
      console.log('üîó ReservationContext - Configuration des listeners WebSocket');

      // Nouvelle r√©servation re√ßue
      const handleNewReservation = (data) => {
        console.log('üì® Nouvelle r√©servation re√ßue:', data);
        const { reservation } = data;

        // Ajouter √† la liste appropri√©e
        if (user.userType === 'tatoueur' && reservation.artistId === currentUserId) {
          setArtistReservations(prev => [reservation, ...prev]);
          toast.success(`Nouvelle r√©servation de ${reservation.clientName}`);
        } else if (user.userType === 'client' && reservation.clientId === currentUserId) {
          setUserReservations(prev => [reservation, ...prev]);
        }

        // Mettre √† jour le cache
        updateReservationInCache(reservation._id, reservation);
      };

      // Statut de r√©servation mis √† jour
      const handleReservationStatusUpdate = (data) => {
        console.log('üîÑ Statut r√©servation mis √† jour:', data);
        const { reservationId, status, updatedReservation } = data;

        // Mettre √† jour dans toutes les listes
        updateReservationInAllLists(reservationId, updatedReservation);

        // Notification selon le statut
        const statusMessages = {
          confirmed: 'R√©servation confirm√©e !',
          cancelled: 'R√©servation annul√©e',
          rejected: 'R√©servation refus√©e',
          completed: 'R√©servation termin√©e'
        };

        if (statusMessages[status]) {
          toast.success(statusMessages[status]);
        }
      };

      // R√©servation supprim√©e
      const handleReservationDeleted = (data) => {
        console.log('üóëÔ∏è R√©servation supprim√©e:', data);
        const { reservationId } = data;

        removeReservationFromAllLists(reservationId);
        toast.info('R√©servation supprim√©e');
      };

      // Rappel de r√©servation
      const handleReservationReminder = (data) => {
        console.log('‚è∞ Rappel de r√©servation:', data);
        const { reservation, message } = data;
        
        toast.info(`Rappel: ${message}`, {
          duration: 6000,
          icon: '‚è∞'
        });
      };

      // Ajouter les listeners
      socket.on('nouvelleReservation', handleNewReservation);
      socket.on('reservationStatusUpdate', handleReservationStatusUpdate);
      socket.on('reservationDeleted', handleReservationDeleted);
      socket.on('reservationReminder', handleReservationReminder);

      // Nettoyer les listeners
      return () => {
        console.log('üßπ ReservationContext - Nettoyage des listeners WebSocket');
        socket.off('nouvelleReservation', handleNewReservation);
        socket.off('reservationStatusUpdate', handleReservationStatusUpdate);
        socket.off('reservationDeleted', handleReservationDeleted);
        socket.off('reservationReminder', handleReservationReminder);
      };
    }
  }, [socket, user, currentUserId, updateReservationInCache, updateReservationInAllLists, removeReservationFromAllLists]);

  // Charger les r√©servations au montage
  useEffect(() => {
    if (user) {
      loadReservations();
    }
  }, [user, loadReservations]);

  // Valeurs du contexte
  const value = {
    // √âtats
    reservations,
    userReservations,
    artistReservations,
    loading,
    error,
    stats,
    filters,
    currentPage,
    totalPages,
    hasMore,

    // Fonctions CRUD
    createFlashReservation,
    createCustomReservation,
    getReservationById,
    updateReservationStatus,
    confirmReservation,
    cancelReservation,
    updateReservation,
    deleteReservation,
    completeReservation,
    sendReminder,

    // Fonctions utilitaires
    getFilteredReservations,
    getGroupedReservations,
    getUpcomingReservations,
    getPendingReservations,
    loadReservations,
    refreshReservations,
    loadMoreReservations,

    // Gestion des filtres
    updateFilters,
    resetFilters,

    // Gestion des erreurs
    clearError,

    // Fonctions utilitaires directes
    canModifyReservation: reservationUtils.canModifyReservation,
    canCancelReservation: reservationUtils.canCancelReservation,
    getStatusLabel: reservationUtils.getStatusLabel,
    getStatusColor: reservationUtils.getStatusColor,
    getTypeLabel: reservationUtils.getTypeLabel,
    formatReservationDate: reservationUtils.formatReservationDate,
    getTimeUntilReservation: reservationUtils.getTimeUntilReservation,
  };

  return (
    <ReservationContext.Provider value={value}>
      {children}
    </ReservationContext.Provider>
  );
}