import React, { createContext, useContext, useEffect, useState } from "react";
import { io } from "socket.io-client";
import { AuthContext } from "../../context/AuthContext";
import { SocketContext } from "../../context/SocketContext";

export const SocketProvider = ({ children }) => {
  const [socket, setSocket] = useState(null);
  const [onlineUsers, setOnlineUsers] = useState([]);
  const { user } = useContext(AuthContext);

  useEffect(() => {
    if (user) {
      console.log("🔌 Connexion WebSocket pour utilisateur:", user._id);

      // Fonction pour récupérer le token depuis les cookies - améliorée
      const getCookie = (name) => {
        if (typeof document === "undefined") return null;

        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) {
          const cookieValue = parts.pop().split(";").shift();
          return decodeURIComponent(cookieValue);
        }
        return null;
      };

      // Fonction de debug pour les cookies
      const debugCookies = () => {
        console.log("🍪 Debug cookies:");
        console.log("- Document cookie:", document.cookie);
        console.log("- Token:", getCookie("token"));
        console.log("- AuthToken:", getCookie("authToken"));
        console.log("- JWT:", getCookie("jwt"));
        console.log("- AccessToken:", getCookie("accessToken"));
      };

      // Debug des cookies
      debugCookies();

      // Essayer plusieurs noms de cookies possibles
      const token =
        getCookie("token") ||
        getCookie("authToken") ||
        getCookie("jwt") ||
        getCookie("accessToken");

      if (!token) {
        console.error("❌ Token non trouvé pour WebSocket");
        console.log(
          "🔍 Vérifiez que le token est bien défini lors de la connexion"
        );
        return;
      }

      console.log(
        "✅ Token trouvé pour WebSocket:",
        token.substring(0, 20) + "..."
      );

      // Créer la connexion socket avec le token
      const newSocket = io(
        process.env.REACT_APP_SERVER_URL || "http://localhost:5000",
        {
          auth: {
            token: token,
          },
          withCredentials: true,
          transports: ["websocket", "polling"], // Permettre plusieurs transports
          timeout: 10000, // Timeout de 10 secondes
          forceNew: true, // Forcer une nouvelle connexion
        }
      );

      // Gestion des événements de connexion
      newSocket.on("connect", () => {
        console.log("✅ WebSocket connecté:", newSocket.id);
        setSocket(newSocket);

        // Rejoindre la room des notifications
        newSocket.emit("joinNotificationRoom");
      });

      newSocket.on("disconnect", (reason) => {
        console.log("❌ WebSocket déconnecté:", reason);
        setSocket(null);
      });

      // Gestion des erreurs de connexion
      newSocket.on("connect_error", (error) => {
        console.error("❌ Erreur connexion WebSocket:", error.message);
        console.log("🔍 Vérifiez:");
        console.log("- Le serveur WebSocket est-il démarré ?");
        console.log("- Le token est-il valide ?");
        console.log("- La configuration CORS côté serveur");
      });

      // Événement d'authentification réussie
      newSocket.on("authenticated", () => {
        console.log("🔐 WebSocket authentifié avec succès");
      });

      // Écouter les utilisateurs en ligne
      newSocket.on("getOnlineUsers", (users) => {
        console.log("👥 Utilisateurs en ligne:", users);
        setOnlineUsers(users);
      });

      // Test de connexion après 2 secondes
      setTimeout(() => {
        if (newSocket.connected) {
          console.log("✅ WebSocket connecté et fonctionnel");
        } else {
          console.warn("⚠️ WebSocket non connecté après 2 secondes");
        }
      }, 2000);

      // Nettoyer lors du démontage
      return () => {
        console.log("🔌 Fermeture connexion WebSocket");
        newSocket.close();
      };
    } else {
      // Si pas d'utilisateur, fermer la connexion
      if (socket) {
        console.log("🔌 Fermeture WebSocket (déconnexion utilisateur)");
        socket.close();
        setSocket(null);
      }
    }
  }, [user]);

  // Fonction utilitaire pour tester la connexion WebSocket
  const testConnection = () => {
    if (socket && socket.connected) {
      console.log("✅ WebSocket connecté");
      socket.emit("test", { message: "Test de connexion" });
      return true;
    } else {
      console.warn("❌ WebSocket non connecté");
      return false;
    }
  };

  return (
    <SocketContext.Provider value={{ socket, onlineUsers, testConnection }}>
      {children}
    </SocketContext.Provider>
  );
};

const { Server } = require("socket.io");
const http = require("http");
const express = require("express");
const jwt = require("jsonwebtoken");

const app = express();
const serverHttp = http.createServer(app);
const io = new Server(serverHttp, {
  cors: {
    origin: process.env.CLIENT_URL,
    methods: ["GET", "POST", "DELETE", "PUT"],
  },
});

const userSocketMap = {};

const getReceiverSocketId = (receiverId) => {
  return userSocketMap[receiverId];
};

// Middleware d'authentification pour Socket.IO
io.use(async (socket, next) => {
  try {
    const token = socket.handshake.auth.token || socket.handshake.query.token;
    
    if (!token) {
      return next(new Error('Token manquant'));
    }

    const decoded = jwt.verify(token, process.env.SECRET_KEY);
    const User = require("../models/user.model");
    const user = await User.findById(decoded.sub);

    if (!user) {
      return next(new Error('Utilisateur non trouvé'));
    }

    socket.userId = user._id.toString();
    socket.user = user;
    next();
  } catch (error) {
    next(new Error('Authentification échouée'));
  }
});

io.on("connection", (socket) => {
  console.log("Utilisateur connecté:", socket.id);
  
  const userId = socket.userId;
  
  if (userId) {
    userSocketMap[userId] = socket.id;
    console.log(`Utilisateur ${userId} mappé au socket ${socket.id}`);
    
    // Joindre l'utilisateur à sa propre room pour les notifications
    socket.join(userId);
  }

  // Émettre la liste des utilisateurs en ligne
  io.emit("getOnlineUsers", Object.keys(userSocketMap));

  // Gérer la demande de notifications en temps réel
  socket.on("joinNotificationRoom", () => {
    if (userId) {
      socket.join(`notifications-${userId}`);
      console.log(`Utilisateur ${userId} a rejoint la room des notifications`);
    }
  });

  // Gérer la déconnexion
  socket.on("disconnect", () => {
    console.log("Utilisateur déconnecté:", socket.id);
    if (userId) {
      delete userSocketMap[userId];
      io.emit("getOnlineUsers", Object.keys(userSocketMap));
    }
  });

  // Gérer l'événement de frappe en cours
  socket.on("typing", ({ conversationId, userId }) => {
    socket.to(conversationId).emit("userTyping", { userId });
  });

  socket.on("stopTyping", ({ conversationId, userId }) => {
    socket.to(conversationId).emit("userStoppedTyping", { userId });
  });

  // Événement pour marquer une notification comme lue en temps réel
  socket.on("markNotificationRead", async ({ notificationId }) => {
    try {
      const Notification = require("../models/notification.model");
      await Notification.findOneAndUpdate(
        { _id: notificationId, idUser: userId },
        { lu: true }
      );
      
      // Confirmer à l'utilisateur que la notification a été marquée comme lue
      socket.emit("notificationMarkedRead", { notificationId });
    } catch (error) {
      socket.emit("error", { message: "Erreur lors du marquage de la notification" });
    }
  });
});

module.exports = { app, serverHttp, io, getReceiverSocketId };

// auth.js
const jwt = require("jsonwebtoken");
const User = require("../models/user.model");

const authentification = async (req, res, next) => {
  const { token } = req.cookies;

  if (!token) {
    return res.status(401).json({ message: "Accès interdit" });
  }

  try {
    const decoded = jwt.verify(token, process.env.SECRET_KEY);
    const user = await User.findById(decoded.sub);

    if (!user) {
      return res.status(401).json({ message: "Utilisateur non trouvé" });
    }

    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ message: "Accès non autorisé" });
  }
};

module.exports = authentification;
const express = require("express");
const cors = require("cors");
const mongoose = require("mongoose");
require("dotenv").config();
const path = require("path");
const cookieParser = require("cookie-parser");
const { serverHttp, app } = require("./socket/socket");

// const __DIRNAME = path.resolve();

const PORT = process.env.API_URL;

// app.use(express.static(path.join(__DIRNAME, "/front/dist")));
app.use(cors({ origin: process.env.CLIENT_URL, credentials: true }));

app.use(express.json());
app.use(cookieParser());

const feedRoutes = require("./routes/feed.routes");
const flashRoutes = require("./routes/flash.routes");
const messagerieRoutes = require("./routes/messagerie.routes");
const notificationRoutes = require("./routes/notification.routes");
const reservationRoutes = require("./routes/reservation.routes");
const userRoutes = require("./routes/user.routes");

app.use("/api/feeds", feedRoutes);
app.use("/api/flashs", flashRoutes);
app.use("/api/messageries", messagerieRoutes);
app.use("/api/notifications", notificationRoutes);
app.use("/api/reservations", reservationRoutes);
app.use("/api/users", userRoutes);

// app.get(/(.*)/, (req, res) => {
//   res.sendFile(path.join(__DIRNAME, "front", "dist", "index.html"));
// });

mongoose.connect(process.env.MONGO_URL).then(() => {
  console.log("✅ MongoDB connected");
  app.listen(process.env.PORT, () => console.log(`🚀 Server on ${PORT}`));
});
