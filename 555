import React, { useState, useEffect, useCallback } from "react";
import { flashApi } from "../../api/flash.api";
import { FlashContext } from "../../context/FlashContext";

export default function FlashProvider({ children }) {

  const [followedFlashes, setFollowedFlashes] = useState([]);
  const [recommendedFlashes, setRecommendedFlashes] = useState([]);
  const [savedFlashes, setSavedFlashes] = useState([]);
  const [allFlashes, setAllFlashes] = useState([]);


  const [flashsCache, setFlashsCache] = useState(new Map());


  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [currentUserId, setCurrentUserId] = useState(null);

 
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [hasMore, setHasMore] = useState(true);

  const updateFlashInAllLists = useCallback((flashId, updatedFlash) => {
    const updateFlashInList = (flashList, setFlashList) => {
      setFlashList((prev) =>
        prev.map((flash) =>
          (flash._id === flashId || flash.id === flashId) ? updatedFlash : flash
        )
      );
    };

    updateFlashInList(allFlashes, setAllFlashes);
    updateFlashInList(followedFlashes, setFollowedFlashes);
    updateFlashInList(recommendedFlashes, setRecommendedFlashes);
    updateFlashInList(savedFlashes, setSavedFlashes);
  }, [allFlashes, followedFlashes, recommendedFlashes, savedFlashes]);

  const updateFlashInCache = useCallback((flashId, updatedFlash) => {
    // Mettre √† jour le cache
    setFlashsCache(prev => {
      const newCache = new Map(prev);
      newCache.set(flashId, updatedFlash);
      return newCache;
    });

    // Mettre √† jour dans toutes les listes
    updateFlashInAllLists(flashId, updatedFlash);

    // √âmettre un √©v√©nement global pour notifier tous les composants
    window.dispatchEvent(new CustomEvent('flashUpdated', {
      detail: { flashId, updatedFlash }
    }));
  }, [updateFlashInAllLists]);

 
  useEffect(() => {
    const handleFlashUpdated = (event) => {
      const { flashId, updatedFlash } = event.detail;
     
      
      // Mettre √† jour dans toutes les listes
      updateFlashInAllLists(flashId, updatedFlash);
    };

    window.addEventListener('flashUpdated', handleFlashUpdated);
    
    return () => {
      window.removeEventListener('flashUpdated', handleFlashUpdated);
    };
  }, [updateFlashInAllLists]);

  
  const getFlashFromCache = useCallback((flashId) => {
    return flashsCache.get(flashId);
  }, [flashsCache]);


  const getCurrentUser = useCallback(() => {
    try {
      // M√©thode 1: localStorage 'user'
      const userFromStorage = localStorage.getItem("user");
      if (userFromStorage) {
        const user = JSON.parse(userFromStorage);
        return user._id || user.id;
      }

      // M√©thode 2: localStorage alternatives
      const altKeys = ["currentUser", "authUser", "loggedUser"];
      for (const key of altKeys) {
        const userData = localStorage.getItem(key);
        if (userData) {
          const user = JSON.parse(userData);
          return user._id || user.id;
        }
      }

      // M√©thode 3: Cookies JWT
      const cookies = document.cookie.split("; ");
      const tokenCookie = cookies.find((row) => row.startsWith("token="));
      if (tokenCookie) {
        const token = tokenCookie.split("=")[1];
        try {
          const payload = JSON.parse(atob(token.split(".")[1]));
          return payload.sub || payload.userId || payload.id || payload._id;
        } catch (jwtError) {
          console.error("Erreur d√©codage JWT:", jwtError);
        }
      }

      return null;
    } catch (error) {
      console.error("Erreur r√©cup√©ration utilisateur:", error);
      return null;
    }
  }, []);

 
  const loadSavedFlashes = useCallback(async () => {
    if (!currentUserId) return;

    try {
     

      const response = await flashApi.getSavedFlashs({
        page: 1,
        limit: 50,
      });

     
      const savedFlashs = response.flashs || [];
      setSavedFlashes(savedFlashs);

    
      setFlashsCache(prev => {
        const newCache = new Map(prev);
        savedFlashs.forEach(flash => {
          const flashId = flash._id || flash.id;
          newCache.set(flashId, flash);
        });
        return newCache;
      });
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur flashs sauvegard√©s:", err);
    }
  }, [currentUserId]);

 
  const loadInitialFlashes = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

    

      // Charger tous les flashs (pour recommendations)
      const response = await flashApi.getFlashs({
        page: 1,
        limit: 20,
        sortBy: "date",
        order: "desc",
      });

      

      const flashs = response.flashs || [];
      setAllFlashes(flashs);

      
      setFlashsCache(prev => {
        const newCache = new Map(prev);
        flashs.forEach(flash => {
          const flashId = flash._id || flash.id;
          newCache.set(flashId, flash);
        });
        return newCache;
      });

   
      setRecommendedFlashes(flashs);
      setFollowedFlashes([]); 

      setCurrentPage(response.currentPage || 1);
      setTotalPages(response.totalPages || 1);
      setHasMore(response.currentPage < response.totalPages);
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur chargement flashs:", err);
      setError(err.message || "Erreur lors du chargement des flashs");
    } finally {
      setLoading(false);
    }
  }, []);

  
  useEffect(() => {
    const userId = getCurrentUser();
    setCurrentUserId(userId);
    
  }, [getCurrentUser]);


  useEffect(() => {
    if (currentUserId) {
      loadInitialFlashes();
      loadSavedFlashes();
    } else {
     
      loadInitialFlashes();
    }
  }, [currentUserId, loadInitialFlashes, loadSavedFlashes]);


  const getFlashesByTatoueur = useCallback(async (tatoueurId, params = {}) => {
    try {
     

      const response = await flashApi.getFlashsByTatoueur(tatoueurId, params);
    

      const flashs = response.flashs || [];

      // Mettre √† jour le cache
      setFlashsCache(prev => {
        const newCache = new Map(prev);
        flashs.forEach(flash => {
          const flashId = flash._id || flash.id;
          newCache.set(flashId, flash);
        });
        return newCache;
      });

      return flashs;
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur flashs tatoueur:", err);
      throw err;
    }
  }, []); // Pas de d√©pendances car la fonction est stable

  
  const getFlashById = useCallback(async (flashId) => {
    try {
    

      // V√©rifier d'abord le cache
      const cachedFlash = getFlashFromCache(flashId);
      if (cachedFlash) {
       
        return cachedFlash;
      }

      // Sinon, charger depuis l'API
      const flash = await flashApi.getFlashById(flashId);
     

      // Mettre √† jour le cache
      updateFlashInCache(flashId, flash);

      return flash;
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur getFlashById:", err);
      throw err;
    }
  }, [getFlashFromCache, updateFlashInCache]);

 
  const addCommentToFlash = useCallback(async (flashId, contenu) => {
    try {
     
      
      const updatedFlash = await flashApi.addComment(flashId, contenu);
      
      // Mettre √† jour le cache et toutes les listes
      updateFlashInCache(flashId, updatedFlash);
      
      return updatedFlash;
    } catch (error) {
      console.error("‚ùå FlashContext - Erreur ajout commentaire:", error);
      throw error;
    }
  }, [updateFlashInCache]);

  const likeCommentInFlash = useCallback(async (flashId, commentId) => {
    try {
      
      
      const updatedFlash = await flashApi.likeComment(flashId, commentId);
      
      // Mettre √† jour le cache et toutes les listes
      updateFlashInCache(flashId, updatedFlash);
      
      return updatedFlash;
    } catch (error) {
      console.error("‚ùå FlashContext - Erreur like commentaire:", error);
      throw error;
    }
  }, [updateFlashInCache]);

  const addReplyToComment = useCallback(async (flashId, commentId, contenu) => {
    try {
     
      
      const updatedFlash = await flashApi.addReplyToComment(flashId, commentId, contenu);
      
      // Mettre √† jour le cache et toutes les listes
      updateFlashInCache(flashId, updatedFlash);
      
      return updatedFlash;
    } catch (error) {
      console.error("‚ùå FlashContext - Erreur ajout r√©ponse:", error);
      throw error;
    }
  }, [updateFlashInCache]);

  const likeReplyInFlash = useCallback(async (flashId, commentId, replyId) => {
    try {
      
      
      const updatedFlash = await flashApi.likeReply(flashId, commentId, replyId);
      
      // Mettre √† jour le cache et toutes les listes
      updateFlashInCache(flashId, updatedFlash);
      
      return updatedFlash;
    } catch (error) {
      console.error("‚ùå FlashContext - Erreur like r√©ponse:", error);
      throw error;
    }
  }, [updateFlashInCache]);

  const deleteCommentFromFlash = useCallback(async (flashId, commentId) => {
    try {
      
      
      await flashApi.deleteComment(flashId, commentId);
      
      // Recharger le flash depuis l'API pour avoir les donn√©es √† jour
      const updatedFlash = await flashApi.getFlashById(flashId);
      
      // Mettre √† jour le cache et toutes les listes
      updateFlashInCache(flashId, updatedFlash);
      
      return updatedFlash;
    } catch (error) {
      console.error("‚ùå FlashContext - Erreur suppression commentaire:", error);
      throw error;
    }
  }, [updateFlashInCache]);

  const deleteReplyFromFlash = useCallback(async (flashId, commentId, replyId) => {
    try {
  
      
      await flashApi.deleteReply(flashId, commentId, replyId);
      
      // Recharger le flash depuis l'API pour avoir les donn√©es √† jour
      const updatedFlash = await flashApi.getFlashById(flashId);
      
      // Mettre √† jour le cache et toutes les listes
      updateFlashInCache(flashId, updatedFlash);
      
      return updatedFlash;
    } catch (error) {
      console.error("‚ùå FlashContext - Erreur suppression r√©ponse:", error);
      throw error;
    }
  }, [updateFlashInCache]);

  
  const addFlash = useCallback(async (flashData) => {
    try {
      
      setLoading(true);

      const newFlash = await flashApi.createFlash(flashData);
      

      // Ajouter le nouveau flash en haut de la liste et dans le cache
      const flashId = newFlash._id || newFlash.id;
      setFlashsCache(prev => {
        const newCache = new Map(prev);
        newCache.set(flashId, newFlash);
        return newCache;
      });

      setAllFlashes((prev) => [newFlash, ...prev]);
      setFollowedFlashes((prev) => [newFlash, ...prev]);

      return newFlash;
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur cr√©ation flash:", err);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

 
  const toggleLikeFlash = useCallback(async (flashId) => {
    try {
    

      const updatedFlash = await flashApi.likeFlash(flashId);
     

      // Mettre √† jour le cache et toutes les listes
      updateFlashInCache(flashId, updatedFlash);

      return updatedFlash;
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur like flash:", err);
      throw err;
    }
  }, [updateFlashInCache]);

  
  const toggleSaveFlash = useCallback(async (flash) => {
    if (!currentUserId) {
      throw new Error("Vous devez √™tre connect√© pour sauvegarder un flash");
    }

    try {
  

      const flashId = flash._id || flash.id;
      const isAlreadySaved = savedFlashes.some(
        (saved) => (saved._id || saved.id) === flashId
      );

      if (isAlreadySaved) {
        // D√©sauvegarder
        await flashApi.unsaveFlash(flashId);
        setSavedFlashes((prev) =>
          prev.filter((saved) => (saved._id || saved.id) !== flashId)
        );
       
      } else {
        // Sauvegarder
        await flashApi.saveFlash(flashId);
        // Recharger la liste compl√®te pour avoir les donn√©es √† jour
        await loadSavedFlashes();
       
      }
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur save flash:", err);
      throw err;
    }
  }, [currentUserId, savedFlashes, loadSavedFlashes]);


  const reserveFlash = useCallback(async (flashId) => {
    try {
    

      const response = await flashApi.reserveFlash(flashId);
    

      // Mettre √† jour le flash dans toutes les listes et le cache
      const updatedFlash = {
        ...getFlashFromCache(flashId),
        reserve: true,
        reservedBy: currentUserId,
        reservedAt: new Date(),
      };

      updateFlashInCache(flashId, updatedFlash);

      return response;
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur r√©servation flash:", err);
      throw err;
    }
  }, [getFlashFromCache, updateFlashInCache, currentUserId]);

 
  const deleteFlash = useCallback(async (flashId) => {
    try {
      

      await flashApi.deleteFlash(flashId);
     

      // Retirer le flash du cache
      setFlashsCache(prev => {
        const newCache = new Map(prev);
        newCache.delete(flashId);
        return newCache;
      });

      // Retirer le flash de toutes les listes
      const removeFlashFromList = (flashList, setFlashList) => {
        setFlashList((prev) =>
          prev.filter((flash) => flash._id !== flashId && flash.id !== flashId)
        );
      };

      removeFlashFromList(allFlashes, setAllFlashes);
      removeFlashFromList(followedFlashes, setFollowedFlashes);
      removeFlashFromList(recommendedFlashes, setRecommendedFlashes);
      removeFlashFromList(savedFlashes, setSavedFlashes);
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur suppression flash:", err);
      throw err;
    }
  }, [allFlashes, followedFlashes, recommendedFlashes, savedFlashes]);

 
  const loadMoreFlashes = useCallback(async () => {
    if (!hasMore || loading) return;

    try {
      setLoading(true);

      const nextPage = currentPage + 1;
     

      const response = await flashApi.getFlashs({
        page: nextPage,
        limit: 20,
        sortBy: "date",
        order: "desc",
      });

      const newFlashes = response.flashs || [];

      if (newFlashes.length > 0) {
        // Ajouter au cache
        setFlashsCache(prev => {
          const newCache = new Map(prev);
          newFlashes.forEach(flash => {
            const flashId = flash._id || flash.id;
            newCache.set(flashId, flash);
          });
          return newCache;
        });

        setAllFlashes((prev) => [...prev, ...newFlashes]);
        setRecommendedFlashes((prev) => [...prev, ...newFlashes]);
        setCurrentPage(nextPage);
        setHasMore(nextPage < response.totalPages);
      } else {
        setHasMore(false);
      }
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur load more:", err);
    } finally {
      setLoading(false);
    }
  }, [hasMore, loading, currentPage]);

 
  const searchFlashes = useCallback(async (searchParams) => {
    try {
      setLoading(true);
      setError(null);

   

      const response = await flashApi.getFlashs({
        ...searchParams,
        page: 1,
        limit: 20,
      });

      const flashs = response.flashs || [];
      setAllFlashes(flashs);
      setRecommendedFlashes(flashs);
      setCurrentPage(1);
      setTotalPages(response.totalPages || 1);
      setHasMore(response.currentPage < response.totalPages);

      // Mettre √† jour le cache
      setFlashsCache(prev => {
        const newCache = new Map(prev);
        flashs.forEach(flash => {
          const flashId = flash._id || flash.id;
          newCache.set(flashId, flash);
        });
        return newCache;
      });

      return response;
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur recherche:", err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

 
  const isFlashSaved = useCallback((flashId) => {
    return savedFlashes.some((flash) => (flash._id || flash.id) === flashId);
  }, [savedFlashes]);

  
  const hasUserLiked = useCallback((flash) => {
    if (!flash.likes || !currentUserId) return false;
    return flash.likes.some(
      (like) => (like.userId?._id || like.userId) === currentUserId
    );
  }, [currentUserId]);

  
  const getLikesCount = useCallback((flash) => {
    return flash.likesCount || flash.likes?.length || 0;
  }, []);

  
  const refreshData = useCallback(async () => {
    try {
      setError(null);
      await loadInitialFlashes();
      if (currentUserId) {
        await loadSavedFlashes();
      }
    } catch (err) {
      console.error("‚ùå FlashContext - Erreur refresh:", err);
      setError(err.message);
    }
  }, [loadInitialFlashes, loadSavedFlashes, currentUserId]);

  
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  const getFlashesByTag = useCallback((tag) => {
    return allFlashes.filter((flash) =>
      flash.tags?.some((flashTag) =>
        flashTag.toLowerCase().includes(tag.toLowerCase())
      )
    );
  }, [allFlashes]);

  const getFlashesByArtist = useCallback((artistId) => {
    return allFlashes.filter(
      (flash) => (flash.idTatoueur?._id || flash.idTatoueur) === artistId
    );
  }, [allFlashes]);

  
  const value = {
    
    followedFlashes,
    recommendedFlashes,
    savedFlashes,
    allFlashes,
    loading,
    error,
    currentUserId,
    flashsCache,

    
    currentPage,
    totalPages,
    hasMore,

    
    getFlashById,
    addFlash,
    deleteFlash,

    
    toggleLikeFlash,
    toggleSaveFlash,
    reserveFlash,

   
    addCommentToFlash,
    likeCommentInFlash,
    addReplyToComment,
    likeReplyInFlash,
    deleteCommentFromFlash,
    deleteReplyFromFlash,

   
    updateFlashInCache,
    getFlashFromCache,

    
    searchFlashes,
    getFlashesByTatoueur,
    getFlashesByTag,
    getFlashesByArtist,
    loadMoreFlashes,

   
    isFlashSaved,
    hasUserLiked,
    getLikesCount,
    refreshData,
    clearError,

    
    setFollowedFlashes,
    setRecommendedFlashes,
    setSavedFlashes,
    setAllFlashes,
  };

  return (
    <FlashContext.Provider value={value}>{children}</FlashContext.Provider>
  );
}

import { BASE_URL } from "../utils/url";

// Configuration des headers par d√©faut
const getHeaders = (includeAuth = true) => {
  const headers = {
    "Content-Type": "application/json",
  };

  return headers;
};

// Configuration des headers pour FormData (multipart)
const getFormDataHeaders = () => {
  const headers = {};

  return headers;
};

// Gestion des erreurs
const handleApiError = async (response) => {
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || errorData.message || "Erreur API");
  }
  return response.json();
};

// API des flashs
export const flashApi = {
  // R√©cup√©rer tous les flashs avec filtres et pagination
  getFlashs: async (params = {}) => {
    try {
      const queryParams = new URLSearchParams();

      // Param√®tres de filtrage
      if (params.disponible !== undefined)
        queryParams.append("disponible", params.disponible);
      if (params.tatoueur) queryParams.append("tatoueur", params.tatoueur);
      if (params.prixMin) queryParams.append("prixMin", params.prixMin);
      if (params.prixMax) queryParams.append("prixMax", params.prixMax);
      if (params.style) queryParams.append("style", params.style);
      if (params.taille) queryParams.append("taille", params.taille);
      if (params.tags) queryParams.append("tags", params.tags);
      if (params.sortBy) queryParams.append("sortBy", params.sortBy);
      if (params.order) queryParams.append("order", params.order);

      // Param√®tres de pagination
      if (params.page) queryParams.append("page", params.page);
      if (params.limit) queryParams.append("limit", params.limit);

      const url = `${BASE_URL}/flashs${
        queryParams.toString() ? `?${queryParams.toString()}` : ""
      }`;

      const response = await fetch(url, {
        method: "GET",
        headers: getHeaders(false),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration des flashs:", error);
      throw error;
    }
  },

  // R√©cup√©rer un flash par ID
  getFlashById: async (flashId) => {
    try {
      const response = await fetch(`${BASE_URL}/flashs/${flashId}`, {
        method: "GET",
        headers: getHeaders(false),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de la r√©cup√©ration du flash:", error);
      throw error;
    }
  },

  // R√©cup√©rer les flashs d'un tatoueur
  getFlashsByTatoueur: async (tatoueurId, params = {}) => {
    try {
      const queryParams = new URLSearchParams();

      // Param√®tres de filtrage
      if (params.disponible !== undefined)
        queryParams.append("disponible", params.disponible);

      // Param√®tres de pagination
      if (params.page) queryParams.append("page", params.page);
      if (params.limit) queryParams.append("limit", params.limit);

      const url = `${BASE_URL}/flashs/tatoueur/${tatoueurId}${
        queryParams.toString() ? `?${queryParams.toString()}` : ""
      }`;

      const response = await fetch(url, {
        method: "GET",
        headers: getHeaders(false),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error(
        "Erreur lors de la r√©cup√©ration des flashs du tatoueur:",
        error
      );
      throw error;
    }
  },

  // Cr√©er un nouveau flash
  createFlash: async (flashData) => {
    try {
      const formData = new FormData();

      // Ajouter les donn√©es obligatoires
      if (flashData.prix) {
        formData.append("prix", flashData.prix);
      }

      if (flashData.description) {
        formData.append("description", flashData.description);
      }

      // Nouvelles donn√©es selon le contr√¥leur
      if (flashData.title) {
        formData.append("title", flashData.title);
      }

      if (flashData.artist) {
        formData.append("artist", flashData.artist);
      }

      if (flashData.style) {
        formData.append("style", flashData.style);
      }

      if (flashData.styleCustom) {
        formData.append("styleCustom", flashData.styleCustom);
      } else {
        console.log(
          "üì§ API - Pas de styleCustom dans flashData:",
          flashData.styleCustom
        );
      }

      if (flashData.taille) {
        formData.append("taille", flashData.taille);
      }

      if (flashData.emplacement) {
        // Si c'est un array, le stringifier
        const emplacementValue = Array.isArray(flashData.emplacement)
          ? JSON.stringify(flashData.emplacement)
          : flashData.emplacement;
        formData.append("emplacement", emplacementValue);
      }

      if (flashData.tags) {
        // Si c'est un array, le stringifier
        const tagsValue = Array.isArray(flashData.tags)
          ? JSON.stringify(flashData.tags)
          : flashData.tags;
        formData.append("tags", tagsValue);
      }

      // Ajouter l'image (obligatoire)
      if (flashData.image) {
        formData.append("image", flashData.image);
      }

      const response = await fetch(`${BASE_URL}/flashs`, {
        method: "POST",
        headers: getFormDataHeaders(),
        body: formData,
        credentials: "include", // Important pour inclure les cookies
      });

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de la cr√©ation du flash:", error);
      throw error;
    }
  },

  // Mettre √† jour un flash
  updateFlash: async (flashId, flashData) => {
    try {
      if (flashData.image && flashData.image instanceof File) {
        const formData = new FormData();

        Object.keys(flashData).forEach((key) => {
          if (key === "emplacement" || key === "tags") {
            const value = Array.isArray(flashData[key])
              ? JSON.stringify(flashData[key])
              : flashData[key];
            formData.append(key, value);
          } else {
            formData.append(key, flashData[key]);
          }
        });

        const response = await fetch(`${BASE_URL}/flashs/${flashId}`, {
          method: "PUT",
          headers: getFormDataHeaders(),
          body: formData,
          credentials: "include",
        });

        return await handleApiError(response);
      } else {
        const response = await fetch(`${BASE_URL}/flashs/${flashId}`, {
          method: "PUT",
          headers: getHeaders(),
          body: JSON.stringify(flashData),
          credentials: "include",
        });

        return await handleApiError(response);
      }
    } catch (error) {
      console.error("Erreur lors de la mise √† jour du flash:", error);
      throw error;
    }
  },

  // Supprimer un flash
  deleteFlash: async (flashId) => {
    try {
      const response = await fetch(`${BASE_URL}/flashs/${flashId}`, {
        method: "DELETE",
        headers: getHeaders(),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de la suppression du flash:", error);
      throw error;
    }
  },

  // Basculer le statut de r√©servation
  toggleReserve: async (flashId) => {
    try {
      const response = await fetch(`${BASE_URL}/flashs/${flashId}/reserve`, {
        method: "PATCH",
        headers: getHeaders(),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error(
        "Erreur lors du changement de statut de r√©servation:",
        error
      );
      throw error;
    }
  },

  // Liker/Unliker un flash
  likeFlash: async (flashId) => {
    try {
      const response = await fetch(`${BASE_URL}/flashs/${flashId}/like`, {
        method: "POST",
        headers: getHeaders(),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors du like du flash:", error);
      throw error;
    }
  },

  // R√©server un flash
  reserveFlash: async (flashId) => {
    try {
      const response = await fetch(`${BASE_URL}/flashs/${flashId}/reserve`, {
        method: "POST",
        headers: getHeaders(),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de la r√©servation du flash:", error);
      throw error;
    }
  },

  // Sauvegarder/Unsauvegarder un flash
  saveFlash: async (flashId) => {
    try {
      const response = await fetch(`${BASE_URL}/flashs/${flashId}/save`, {
        method: "POST",
        headers: getHeaders(),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de la sauvegarde du flash:", error);
      throw error;
    }
  },

  // Supprimer un flash des favoris
  unsaveFlash: async (flashId) => {
    try {
      const response = await fetch(`${BASE_URL}/flashs/${flashId}/save`, {
        method: "DELETE",
        headers: getHeaders(),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error(
        "Erreur lors de la suppression du flash des favoris:",
        error
      );
      throw error;
    }
  },

  // R√©cup√©rer les flashs sauvegard√©s
  getSavedFlashs: async (params = {}) => {
    try {
      const queryParams = new URLSearchParams();

      if (params.page) queryParams.append("page", params.page);
      if (params.limit) queryParams.append("limit", params.limit);

      const url = `${BASE_URL}/flashs/saved${
        queryParams.toString() ? `?${queryParams.toString()}` : ""
      }`;

      const response = await fetch(url, {
        method: "GET",
        headers: getHeaders(),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error(
        "Erreur lors de la r√©cup√©ration des flashs sauvegard√©s:",
        error
      );
      throw error;
    }
  },

  // Ajouter un commentaire
  addComment: async (flashId, contenu) => {
    try {
      const response = await fetch(`${BASE_URL}/flashs/${flashId}/comments`, {
        method: "POST",
        headers: getHeaders(),
        body: JSON.stringify({ contenu }),
        credentials: "include",
      });

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de l'ajout du commentaire:", error);
      throw error;
    }
  },

  // Supprimer un commentaire
  deleteComment: async (flashId, commentId) => {
    try {
      const response = await fetch(
        `${BASE_URL}/flashs/${flashId}/comments/${commentId}`,
        {
          method: "DELETE",
          headers: getHeaders(),
          credentials: "include",
        }
      );

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de la suppression du commentaire:", error);
      throw error;
    }
  },

  // Liker un commentaire
  likeComment: async (flashId, commentId) => {
    try {
      const response = await fetch(
        `${BASE_URL}/flashs/${flashId}/comments/${commentId}/like`,
        {
          method: "POST",
          headers: getHeaders(),
          credentials: "include",
        }
      );

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors du like du commentaire:", error);
      throw error;
    }
  },

  // Ajouter une r√©ponse √† un commentaire
  addReplyToComment: async (flashId, commentId, contenu) => {
    try {
      const response = await fetch(
        `${BASE_URL}/flashs/${flashId}/comments/${commentId}/replies`,
        {
          method: "POST",
          headers: getHeaders(),
          body: JSON.stringify({ contenu }),
          credentials: "include",
        }
      );

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de l'ajout de la r√©ponse:", error);
      throw error;
    }
  },

  // Liker une r√©ponse
  likeReply: async (flashId, commentId, replyId) => {
    try {
      const response = await fetch(
        `${BASE_URL}/flashs/${flashId}/comments/${commentId}/replies/${replyId}/like`,
        {
          method: "POST",
          headers: getHeaders(),
          credentials: "include",
        }
      );

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors du like de la r√©ponse:", error);
      throw error;
    }
  },

  // Supprimer une r√©ponse
  deleteReply: async (flashId, commentId, replyId) => {
    try {
      const response = await fetch(
        `${BASE_URL}/flashs/${flashId}/comments/${commentId}/replies/${replyId}`,
        {
          method: "DELETE",
          headers: getHeaders(),
          credentials: "include",
        }
      );

      return await handleApiError(response);
    } catch (error) {
      console.error("Erreur lors de la suppression de la r√©ponse:", error);
      throw error;
    }
  },
};

// Fonctions utilitaires pour les flashs (nettoy√©es sans rating)
export const flashUtils = {
  // V√©rifier si un flash est disponible
  isAvailable: (flash) => {
    return flash.disponible && !flash.reserve;
  },

  // V√©rifier si un flash est r√©serv√©
  isReserved: (flash) => {
    return flash.reserve;
  },

  // Formater le prix
  formatPrice: (price) => {
    return new Intl.NumberFormat("fr-FR", {
      style: "currency",
      currency: "EUR",
    }).format(price);
  },

  // Formater la date
  formatDate: (dateString) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffTime = Math.abs(now - date);
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

    if (diffDays === 0) {
      return "Aujourd'hui";
    } else if (diffDays === 1) {
      return "Hier";
    } else if (diffDays < 7) {
      return `Il y a ${diffDays} jours`;
    } else {
      return date.toLocaleDateString("fr-FR", {
        day: "numeric",
        month: "long",
        year: "numeric",
      });
    }
  },

  // Obtenir le statut du flash
  getStatus: (flash) => {
    if (!flash.disponible) return "Indisponible";
    if (flash.reserve) return "R√©serv√©";
    return "Disponible";
  },

  // Obtenir la couleur du badge de statut
  getStatusColor: (flash) => {
    if (!flash.disponible) return "gray";
    if (flash.reserve) return "orange";
    return "green";
  },

  // Valider les donn√©es d'un flash avant cr√©ation
  validateFlashData: (flashData) => {
    const errors = [];

    if (!flashData.image) {
      errors.push("Une image est requise");
    }

    if (!flashData.prix || isNaN(flashData.prix) || flashData.prix < 0) {
      errors.push("Un prix valide est requis");
    }

    if (flashData.prix && flashData.prix > 10000) {
      errors.push("Le prix ne peut pas d√©passer 10 000‚Ç¨");
    }

    if (flashData.description && flashData.description.length > 500) {
      errors.push("La description ne peut pas d√©passer 500 caract√®res");
    }

    // Validation pour les nouveaux champs
    if (flashData.title && flashData.title.length > 100) {
      errors.push("Le titre ne peut pas d√©passer 100 caract√®res");
    }

    if (flashData.artist && flashData.artist.length > 100) {
      errors.push("Le nom de l'artiste ne peut pas d√©passer 100 caract√®res");
    }

    return errors;
  },

  // Filtrer les flashs par crit√®res (mis √† jour avec nouveaux filtres)
  filterFlashs: (flashs, filters) => {
    return flashs.filter((flash) => {
      // Filtre par disponibilit√©
      if (
        filters.disponible !== undefined &&
        flash.disponible !== filters.disponible
      ) {
        return false;
      }

      // Filtre par prix minimum
      if (filters.prixMin && flash.prix < filters.prixMin) {
        return false;
      }

      // Filtre par prix maximum
      if (filters.prixMax && flash.prix > filters.prixMax) {
        return false;
      }

      // Filtre par tatoueur
      if (filters.tatoueur && flash.idTatoueur._id !== filters.tatoueur) {
        return false;
      }

      // Filtre par style
      if (filters.style && flash.style !== filters.style) {
        return false;
      }

      // Filtre par taille
      if (filters.taille && flash.taille !== filters.taille) {
        return false;
      }

      // Filtre par tags
      if (filters.tags && filters.tags.length > 0) {
        const flashTags = flash.tags || [];
        const hasMatchingTag = filters.tags.some((tag) =>
          flashTags.some((flashTag) =>
            flashTag.toLowerCase().includes(tag.toLowerCase())
          )
        );
        if (!hasMatchingTag) {
          return false;
        }
      }

      return true;
    });
  },

  // Trier les flashs (nettoy√© sans rating)
  sortFlashs: (flashs, sortBy = "date", order = "desc") => {
    return flashs.sort((a, b) => {
      let valueA, valueB;

      switch (sortBy) {
        case "prix":
          valueA = a.prix;
          valueB = b.prix;
          break;
        case "views":
          valueA = a.views || 0;
          valueB = b.views || 0;
          break;
        case "likes":
          valueA = a.likesCount || a.likes?.length || 0;
          valueB = b.likesCount || b.likes?.length || 0;
          break;
        case "date":
        default:
          valueA = new Date(a.date || a.createdAt);
          valueB = new Date(b.date || b.createdAt);
          break;
      }

      if (order === "asc") {
        return valueA > valueB ? 1 : -1;
      } else {
        return valueA < valueB ? 1 : -1;
      }
    });
  },

  // Calculer les statistiques des flashs (nettoy√© sans rating)
  getStats: (flashs) => {
    const total = flashs.length;
    const disponibles = flashs.filter((f) => f.disponible && !f.reserve).length;
    const reserves = flashs.filter((f) => f.reserve).length;
    const indisponibles = flashs.filter((f) => !f.disponible).length;

    const prix = flashs.map((f) => f.prix);
    const prixMoyen =
      prix.length > 0 ? prix.reduce((a, b) => a + b, 0) / prix.length : 0;
    const prixMin = prix.length > 0 ? Math.min(...prix) : 0;
    const prixMax = prix.length > 0 ? Math.max(...prix) : 0;

    // Stats d'engagement (sans rating)
    const totalLikes = flashs.reduce(
      (acc, f) => acc + (f.likesCount || f.likes?.length || 0),
      0
    );
    const totalViews = flashs.reduce((acc, f) => acc + (f.views || 0), 0);

    return {
      total,
      disponibles,
      reserves,
      indisponibles,
      prix: {
        moyen: prixMoyen,
        min: prixMin,
        max: prixMax,
      },
      engagement: {
        totalLikes,
        totalViews,
      },
    };
  },

  // V√©rifier si l'utilisateur a lik√© un flash
  hasUserLiked: (flash, userId) => {
    if (!flash.likes || !userId) return false;
    return flash.likes.some(
      (like) => like.userId._id === userId || like.userId === userId
    );
  },

  // V√©rifier si l'utilisateur a sauvegard√© un flash
  hasUserSaved: (savedFlashs, flashId) => {
    if (!savedFlashs || !flashId) return false;
    return savedFlashs.some((saved) => (saved._id || saved) === flashId);
  },
};

export default flashApi;
